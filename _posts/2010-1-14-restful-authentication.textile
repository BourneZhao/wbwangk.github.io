---
layout: blog
title: RESTful Authentication in Rails
summary: A breakdown of how I wrote RESTful authentication in Ruby on Rails, and how I maintain state.
---

h1. {{ page.title }}

p. 14 Jan 2010 - Kyoto, Japan

I have to admit this is the first time I've really explored writing an authenticated RESTful application, so the concepts are completely new to me.  If any purists out there want to slap me up the side the head, please do so knowing just how much of a newbie I am to this topic.  Hopefully what I've published here makes sense, and the whole key exchange and authenticating bit actually work in practice.  Unfortunately sleep has been a fleeting concept to my body and mind as of late, I have written both this system and blog post at the tail end of I have no idea how many hours, days, weeks of little to no sleep.

Anyways, to kick things off I will make an attempt to illustrate what I tried to achieve.  For starters, the obvious goal was to get a user authenticated into the system.  Ideally this is done over an SSL connection so that all client username/password data remains encrypted, as well as the key the server generates and returns.

{% highlight ruby linenos %}
def login
  if request.post?
    if user = User.authenticate(params[:username], params[:password])
      # Remove any old sessions
      RestfulUser.find(:all, :username => user.username).each {|ru| ru.destroy}
      # Create a new session
      crypt_key = Digest::MD5.hexdigest(Time.now.to_s + rand(2**128).to_s(16))
      ru = RestfulUser.create(
        :username => user.username,
        :crypt_key => crypt_key,
        :session_id => Digest::MD5.hexdigest(Time.now.to_s + user.username),
        :session_timeout => 1.hour.to_i
      )
      render :text => {:crypt_key => ru.crypt_key, :session_id => ru.session_id, :session_timeout => ru.session_timeout}.to_json
    else
      render :text => {:error => "Auth Failed"}.to_json
    end  
  end
end
{% endhighlight %}

The first thing which happens is we authenticate the user.  Assuming they authenticated correctly, any old sessions laying around inside RestfulUser get removed, and a new session is created.  Inside we store the username for internal lookup purposes, and the session_id which gets handed to the client along with the crypt_key and session_timeout.  The theory here is that since we are using an SSL connection, the crypt_key should be secure.  Good enough for banks, good enough for me.

My existing codebase isn't making use of the session_timeout yet, but eventually that will get checked during a RESTful request and return a "LOGIN_RETRY" code signaling the client to login and try the request again.  There's no particularly good reason I chose md5 here other than it was available.  The "Auth Failed" bit should actually be some kind of response code.

After the client has authenticated, they can start spitting requests at the server using straight up standard HTTP.  This could be written better, but the following code is how the client gets verified and data returned.  Note that Zlib.crc32 was just another random choice, mainly because it takes a seed value (maybe I am misusing it).  In this case the client is trying to make a call to _/restful/user_count_.

{% highlight ruby linenos %}
def auth_string(u, p, s)
  Zlib.crc32(u + p, s.to_i)
end

def restful_auth(session_id, auth)
  ru = RestfulUser.find(:first, :session_id => session_id)
  user = User.find(:first, :username => ru.username)
  auth.to_i == auth_string(ru.username, user.password, ru.crypt_key).to_i ? true : false
end

def user_count
  if restful_auth(params[:session_id], params[:auth])
    render :text => User.count
  else
    render :text => "ERROR"
  end
end
{% endhighlight %}

The user_count method takes the passed session_id and auth value parameters, and verifies that the user is who they say they are.  The auth parameter was generated with the auth_string method on the client side using their username, password, and the crypt_key as the seed.  The restful_auth method first loads the RestfulUser based on the session id, fetches the related User information, crypts that User's information via auth_string with their username, password, and the stored crypt_key, and checks if it matches the auth parameter passed in the request.  If they match, then we have a valid request, and data can happily be returned to the client.

The following are the Restful Controller and Client code in their entirety.

_restful_controller.rb_

{% highlight ruby linenos %}
require 'digest/md5'
require 'zlib'

class RestfulController < ActionController::Base
  
  def auth_string(u, p, s)
    Zlib.crc32(u + p, s.to_i)
  end
  
  def restful_auth(session_id, auth)
    ru = RestfulUser.find(:first, :session_id => session_id)
    user = User.find(:first, :username => ru.username)
    auth.to_i == auth_string(ru.username, user.password, ru.crypt_key).to_i ? true : false
  end
  
  def login
    if request.post?
      if user = User.authenticate(params[:username], params[:password])
        # Remove any old sessions
        RestfulUser.find(:all, :username => user.username).each {|ru| ru.destroy}
        # Create a new session
        crypt_key = Digest::MD5.hexdigest(Time.now.to_s + rand(2**128).to_s(16))
        ru = RestfulUser.create(
          :username => user.username,
          :crypt_key => crypt_key,
          :session_id => Digest::MD5.hexdigest(Time.now.to_s + user.username),
          :session_timeout => 1.hour.to_i
        )
        render :text => {:crypt_key => ru.crypt_key, :session_id => ru.session_id, :session_timeout => ru.session_timeout}.to_json
      else
        render :text => {:error => "Auth Failed"}.to_json
      end  
    end
  end
  
  def user_count
    if restful_auth(params[:session_id], params[:auth])
      render :text => User.count
    else
      render :text => "ERROR"
    end
  end
  
end
{% endhighlight %}

_client.rb_

{% highlight ruby linenos %}
# Requires http://github.com/toland/patron
require 'rubygems'
require 'patron'
require 'activesupport'
require 'zlib'

sess = Patron::Session.new
sess.timeout = 10
sess.base_url = "http://localhost:3000"
sess.headers['User-Agent'] = 'patron-client/1.0'

username = "my_user"
password = "my_password"

def auth_string(u, p, s)
  Zlib.crc32(u + p, s.to_i)
end

# User Authentication
resp = sess.post("/restful/login", "username=#{username}&password=#{password}")

if resp.status < 400
  login = ActiveSupport::JSON.decode(resp.body)
end

#######################################
# RESTful calls
#######################################

# User Count
resp = sess.post(
  "/restful/user_count",
  "session_id=%s&auth=%s" % [login["session_id"], auth_string(username, password, login["crypt_key"])]
)

if resp.status < 400
  puts "User Count: %s" % resp.body
end
{% endhighlight %}

In conclusion, I hope that anyone reading this has a good idea about how to implement their own little RESTful API in Ruby.  I'll note again that I am be no means even sure I have approached this correctly, but am confident that my implementation will work as I expect.  At the very least my test client behaves as I'd expect it too.

The long term goal of this is to provide an API for future extensibility to the application I am building, either by allowing me to break out my Rails applications into a 3 tiered application tier for performance reasons, or connecting random 3rd party clients to it.